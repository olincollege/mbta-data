---
title: "main"
output: html_document
date: "2024-04-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# Packages
if (!"pacman" %in% installed.packages()) {
  install.packages("pacman")
}
# load pacman
library(pacman)

# Use pacman to install and load libraries
pacman::p_load(
  "forcats", "dplyr", "readr", "ggplot2", "sfheaders",
  "geojsonsf", "sf", "purrr", "ggmap", "ggthemes",
  "tidycensus", "scales", "patchwork", "tidyverse"
)
```

API Keys: DO NOT COMMIT
```{r}
# 


```


## Import Data
```{r}
df <- read.csv("GSE_by_year/GSE_2016.csv")
```


## Map visualisations

```{r}
# Aggregate the data by station and calculate the sum of entries
df_station_sum <- df %>%
  group_by(station_name) %>%
  summarise(total_entries = sum(gated_entries))

# get stop location data
tstops <- geojsonsf::geojson_sf("stops.geojson")
tstops <- tstops %>%
  mutate(
    lon = unlist(map(tstops$geometry, 1)),
    lat = unlist(map(tstops$geometry, 2))
  )
stations <- left_join(df_station_sum, tstops, by = c("station_name" = "name"))
```


```{r}
mymap <- get_stadiamap(
  bbox = c(
    left = -71.1681, bottom = 42.2255,
    right = -70.9634, top = 42.4387
  ),
  maptype = "stamen_toner_lite",
  messaging = FALSE,
  zoom = 11
)
```

```{r}
ggmap(mymap) + # creates the map "background"
  geom_point(
    data = stations,
    aes(x = lon, y = lat, color = total_entries),
    size = 2
  ) +
  theme_map()
```


## Race Distribution Visualization in Suffolk County

```{r, "race facet plots"}

# these are the codes that are needed to call from the census data

racevars <- c(White = "B02001_002", 
              Black = "B02001_003", 
              Asian = "B02001_005",
              `Two or more` = "B02001_008" )

# getting the 5-year census data relevant to Suffolk county and the population
# data about black, white, asian, and multi-racial people in
# this county in 2016 and 2022

boston_race_16 <- get_acs(
  geography = "cbg",
  variables = racevars,
  state = "MA",
  county = "Suffolk",
  geometry = TRUE,
  summary_var = "B02001_001",
  year = 2016,
)
boston_race_22 <- get_acs(
  geography = "cbg",
  variables = racevars,
  state = "MA",
  county = "Suffolk",
  geometry = TRUE,
  summary_var = "B02001_001",
  year = 2022,
)


# plotting the percent of the population that is each race in suffolk county in 2022
# and 2016 in the style of a choropleth map with the station locations layed overtop

br_1 <- boston_race_16 %>%
  mutate(percent = 100 * (estimate / summary_est)) %>%
  ggplot(aes(fill = percent)) +
  facet_wrap(~variable) +
  geom_sf(color = NA) +
  theme_void() +
  scale_fill_viridis_c() +
  labs(
    title = "Demographics of the Suffolk County",
    subtitle = "2016 census"
  ) +
  theme(legend.position = "None")

br_2 <- boston_race_22 %>%
  mutate(percent = 100 * (estimate / summary_est)) %>%
  ggplot(aes(fill = percent)) +
  facet_wrap(~variable) +
  geom_sf(color = NA) +
  theme_void() +
  scale_fill_viridis_c() +
  labs(fill = "% of population", subtitle = "2022 census") +
  theme(legend.position = "bottom")

#plotting the two years side by side using patchwork
br_1 + br_2
```

# Load Census Data on Income
```{r}
options(tigris_use_cache = TRUE)

# getting the 5-year census data relevant to Suffolk county and the 
#median income of each block group in
# this county in 2016 and 2022

boston_income_16 <- get_acs(
  state = "MA",
  county = "Suffolk",
  geography = "cbg",
  variables = "B19013_001",
  geometry = TRUE,
  year = 2016
)

boston_income_22 <- get_acs(
  state = "MA",
  county = "Suffolk",
  geography = "cbg",
  variables = "B19013_001",
  geometry = TRUE,
  year = 2022
)
```


## Census Block mapping 
```{r}
# these are the codes that are needed to call from the census data
transvars <- c(
  Subway = "B08301_013",
  Lightrail = "B08301_012"
)

# pull Suffolk county's census information (in blocks) through the census API
boston_tract_location <- get_acs(
  state = "MA",
  county = "Suffolk",
  geography = "cbg",
  variables = transvars,
  geometry = TRUE,
  year = 2016,
)

# filter so we only have the light rail data
boston_tract_location <- filter(
  boston_tract_location,
  variable == "Subway"
)
```


```{r}
# find the "center point" of all the block border polygons
boston_tract_location$center_of_geo <-
  st_coordinates(sf::st_centroid(x = boston_tract_location$geometry))

# filter out stations that don't have a location on file
boston_station_location <- stations %>%
  filter(is.na(lat) == FALSE)
```

```{r}
boston_tract_location$nearest_station <- ""

# for every block in the census
for (i in 1:length(boston_tract_location$NAME)) {
  # find distance between all station and the block we're looping through
  boston_station_location$distance <-
    sqrt((boston_station_location$lat -
      boston_tract_location$center_of_geo[i, 2])^2 +
      (boston_station_location$lon -
        boston_tract_location$center_of_geo[i, 1])^2)

  # put the station name that has the shortest distance in the block dataframe
  boston_tract_location$nearest_station[i] <-
    boston_station_location$station_name[
      boston_station_location$distance == min(boston_station_location$distance)
    ]
}

boston_station_location <- boston_station_location %>%
  select(-c("distance"))
```


## Nearest Station Plotting
```{r}
# Plots out which blocks are assigned to which station, more so just a graphical representation
# to check if our block mapping was correct

census_stations <- ggplot() +
  geom_sf(data = boston_tract_location, aes(
    fill = nearest_station
  ), color = "black") +
  theme_void() +
  theme(
    legend.text = element_text(size = 4)
  ) +
  geom_point(data = stations, aes(x = lon, y = lat))

census_stations
```


## Normalize entries for population
```{r}
# Get total entries for 2016
station16 <- read.csv("GSE_by_year/GSE_2016.csv")

# Aggregate the data by station and calculate the sum of entries for 2016
station_sum16 <- station16 %>%
  group_by(station_name) %>%
  summarise(total_entries = sum(gated_entries))

# join with stops
station16 <- left_join(station_sum16, tstops, by = c("station_name" = "name"))

# Get total entries for 2022
station22 <- read.csv("GSE_by_year/GSE_2022.csv")

# Aggregate the data by station and calculate the sum of entries for 2022
station_sum22 <- station22 %>%
  group_by(station_name) %>%
  summarise(total_entries = sum(gated_entries))

#join with stops
station22 <- left_join(station_sum22, tstops, by = c("station_name" = "name"))


# Find population for 2016
tract_station_population16 <-
  st_join(boston_tract_location, boston_race_16)
tract_station_population16 <-
  group_by(tract_station_population16, nearest_station)
norm_station_populations16 <-
  summarise(tract_station_population16, population = sum(summary_est))

# Convert 2016 stations to not have geometry
norm_station_populations16 <-
  sf_to_df(norm_station_populations16, fill = TRUE, unlist = NULL)

# join populations and station entries to have both and remove NAs
norm_station_populations16 <-
  left_join(station16, norm_station_populations16,
    by = c("station_name" = "nearest_station")
  )
norm_station_populations16 <- norm_station_populations16 %>%
  group_by(station_name) %>%
  summarise(
    total_entries =
      mean(total_entries), population = mean(population),
    lon = mean(lon), lat = mean(lat)
  )

# normalize data
norm_station_populations16$norm_entries <-
  norm_station_populations16$total_entries /
    norm_station_populations16$population
```

```{r}
# Find population for 2022
tract_station_population22 <- st_join(
  boston_tract_location, boston_race_22
)
tract_station_population22 <- group_by(
  tract_station_population22, nearest_station
)
norm_station_populations22 <- summarise(
  tract_station_population22,
  population = sum(summary_est)
)

# Convert 2016 stations to not have geometry
norm_station_populations22 <- sf_to_df(
  norm_station_populations22,
  fill = TRUE, unlist = NULL
)

# join populations and station entries to have both and remove NAs
norm_station_populations22 <- left_join(
  station22, norm_station_populations22,
  by = c("station_name" = "nearest_station")
)
norm_station_populations22 <- norm_station_populations22 %>%
  group_by(station_name) %>%
  summarise(
    total_entries = mean(total_entries),
    population = mean(population), lon = mean(lon), lat = mean(lat)
  )

# normalize data
norm_station_populations22$norm_entries <-
  norm_station_populations22$total_entries /
    norm_station_populations22$population
```

## Make linear regression models

```{r}
# Join normalized entries with racial data
# for 2016
station_races16 <- left_join(
  norm_station_populations16, boston_tract_location,
  by = c("station_name" = "nearest_station")
)
station_race16 <- left_join(
  select(station_races16, -c("variable", "estimate", "moe")), boston_race_16
) %>% mutate(percent = 100 * (estimate / summary_est))
station_race16$race <- station_race16$variable

# for 2022
station_races22 <- left_join(
  norm_station_populations22, boston_tract_location,
  by = c("station_name" = "nearest_station")
)
station_race22 <- left_join(
  select(station_races22, -c("variable", "estimate", "moe")),
  select(boston_race_22, c(
    "GEOID", "variable", "estimate", "summary_est", "moe"
  )),
  by = c("GEOID" = "GEOID")
) %>% mutate(percent = 100 * (estimate / summary_est))
station_race22$race <- station_race22$variable


# Join normalized entries with income data
# for 2016
station_race16 <- left_join(
  select(station_race16, -c("variable", "estimate", "moe")), boston_income_16
)
station_race16$income <- station_race16$estimate
station_race16 <- select(
  station_race16, c("norm_entries", "station_name", "percent", "income", "race")
)

# for 2022
station_race22 <- left_join(
  select(
    station_race22, -c("variable", "estimate", "moe")
  ), select(boston_income_22, c("GEOID", "estimate"))
)
station_race22$income <- station_race22$estimate
station_race22 <- select(
  station_race22, c("norm_entries", "station_name", "percent", "income", "race")
)

# Remove NA and hispanic race because we don't have enough data for that
station_race16 <- filter(station_race16, race != "Hispanic")
station_race22 <- filter(station_race22, race != "Hispanic")
```

# Plot Normalized Light Rail Entry

```{r}
# Plot Normalized Light Rail Station Entry in 2022
norm_station_entry_22 <- ggplot() +
  geom_sf(data = boston_tract_location, color = NA, fill = "gray") +
  theme_void() +
  theme(
    legend.text = element_text(size = 4)
  ) +
  geom_point(
    data = norm_station_populations22,
    aes(x = lon, y = lat, fill = norm_entries),
    color = "black",
    size = 3,
    shape = 21
  ) +
  ggtitle("Normalized Lightrail Station Entry 2022")+
  scale_fill_gradientn(colours = c("red", "purple", "blue"), values = c(0, 0.2, 1), na.value = NA, name = "entry per person")

norm_station_entry_22
```

```{r}
# Plot Normalized Light Rail Station Entry in 2016
norm_station_entry_16 <- ggplot() +
  geom_sf(data = boston_tract_location, color = NA, fill = "gray") +
  theme_void() +
  theme(
    legend.text = element_text(size = 4)
  ) +
  geom_point(
    data = norm_station_populations16,
    aes(x = lon, y = lat, fill = norm_entries),
    color = "black",
    size = 3,
    shape = 21
  ) +
  ggtitle("Normalized Lightrail Station Entry 2016")+
  scale_fill_gradientn(colours = c("red", "purple", "blue"), values = c(0, 0.1, 1), na.value = NA, name = "entry per person")

norm_station_entry_16
```
## Regression on Gated Entry vs income

```{r}
lm_entry_income <- lm(norm_entries ~ income, data = station_race16)
summary(lm_entry_income)
```

```{r}
ggplot()+geom_point(aes(station_race16$income,station_race16$norm_entries))+
  geom_line(aes(station_race16$income, predict(lm_entry_income, newdata = station_race16)))+
  ggtitle('normalized gated entries vs. income')+
  xlab('median income')+
  ylab('normalized gated entries')
```
## Linear Regression on Filtered data
```{r}
# Filter data for entries more than 125 (outliers)
filtered_data <- subset(station_race16, norm_entries < 125)
# Filter data for income more than 125000 (too less data points)
filtered_data <- subset(filtered_data, income < 125000)

lm_entry_income_filtered <- lm(norm_entries ~ 1 + income, data = filtered_data)
summary(lm_entry_income_filtered)

# Plotting
ggplot(filtered_data) +
  geom_point(aes(x=income, y=norm_entries)) +
  geom_line(aes(income, predict(lm_entry_income_filtered, newdata = filtered_data))) +
  ggtitle('Normalized Station Entries vs. Income') +
  xlab('Median Income')+
  ylab('Filtered Formalized Station entries')
```
## Regression on Gated Entry vs race
```{r}
# Filter data for entries more than 125 (outliers)
filtered_data_black <- station_race16 %>% 
  subset(norm_entries < 125) %>% 
  subset(race == "Black")

lm_entry_black_filtered <- lm(norm_entries ~ 1 + percent, data = filtered_data_black)
summary(lm_entry_income_filtered)

# Plotting
ggplot(filtered_data_black) +
  geom_point(aes(percent, norm_entries)) +
  geom_line(aes(percent, predict(lm_entry_black_filtered, newdata = filtered_data_race))) +
  ggtitle('Normalized Gated Entries vs. Race') +
  xlab('Percent Black')+
  ylab('Normalized Station Entries')
```

```{r}
filtered_data_white <- station_race16 %>% 
  subset(norm_entries < 125) %>% 
  subset(race == "White")


lm_entry_white_filtered <- lm(norm_entries ~ 1 + percent, data = filtered_data_white)
summary(lm_entry_income_filtered)

# Plotting
ggplot(filtered_data_white) +
  geom_point(aes(percent, norm_entries)) +
  geom_line(aes(percent, predict(lm_entry_white_filtered, newdata = filtered_data_white))) +
  ggtitle('Normalized Gated Entries vs. Race') +
  xlab('Percent White')+
  ylab('Normalized Station Entries')
```



```{r}
station_populations_16_22 <- norm_station_populations22 %>% 
  filter(!is.na(norm_entries))

for (i in 1:length(station_populations_16_22$station_name)){
  norm_entry_16 <- norm_station_populations16$norm_entries[norm_station_populations16$station_name == station_populations_16_22$station_name[i]]
  norm_entry_22 <- station_populations_16_22$norm_entries
  station_populations_16_22$diff_norm_entry[i] <- (norm_entry_22 - norm_entry_16)
}
  

diff_norm_station_entry <- ggplot() +
  geom_sf(data = boston_tract_location, color = NA, fill = "gray") +
  theme_void() +
  geom_point(
    data = station_populations_16_22,
    aes(x = lon, y = lat, fill = diff_norm_entry),
    color = "black",
    shape = 21,
    size = 3
  ) +
  ggtitle("Difference in Light Rail Usage from 2016 - 2022") + 
  scale_fill_gradientn(colours = c("red", "yellow", "green"), values = c(0, 0.9875, 1), na.value = NA, name = "# of Rider Increase in 2022")

diff_norm_station_entry
```

```{r}
station_populations_16_22$increase_usage <- (station_populations_16_22$diff_norm_entry > 0)

diff_norm_station_entry <- ggplot() +
  geom_sf(data = boston_tract_location, color = NA, fill = "gray") +
  theme_void() +
  geom_point(
    data = station_populations_16_22,
    aes(x = lon, y = lat, fill = increase_usage),
    color = "black",
    shape = 21,
    size = 3
  ) +
  ggtitle("Whether Usage of Station Increased from 2016 - 2022")

diff_norm_station_entry
```


```{r}
ggplot(station_populations_16_22) + 
  geom_col(aes(x = fct_reorder(station_name, diff_norm_entry), y = diff_norm_entry, fill = diff_norm_entry))+
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+
  xlab("stations") + 
  ylab("difference in usage between 2016 and 2022")+ 
  scale_fill_gradientn(colours = c("red", "yellow", "green"), values = c(0, 0.9875, 1), na.value = NA, name = "# of extra Rider Increase in 2022")
```


```{r, "median income"}
# plotting the median income in suffolk county in 2022 and 2016
# in the style of a choropleth map with the station locations layed overtop
bi_1 <- boston_income_16 %>%
  ggplot(aes(fill = estimate)) +
  geom_sf(color = NA) +
  geom_point(
    data = station_populations_16_22,
    aes(x = lon, y = lat, fill = diff_norm_entry),
    color = "blue")+
  theme_void() +
  scale_fill_viridis_c(
    option = "inferno",
    labels = scales::dollar,
    limits = c(0, 250000)
  ) +
  labs(
    title = "Median Household income in Suffolk County",
    subtitle = "2016 census"
  ) +
  theme(legend.position = "None")

bi_2 <- boston_income_22 %>%
  ggplot(aes(fill = estimate)) +
  geom_sf(color = NA) +
  geom_point(
    data = station_populations_16_22,
    aes(x = lon, y = lat, fill = diff_norm_entry),
    color = "blue")+
  theme_void() +
  scale_fill_viridis_c(
    option = "inferno",
    labels = scales::dollar,
    limits = c(0, 250000)
  ) +
  labs(fill = "Median Household income", subtitle = "2022 census") +
  theme(legend.position = "right")

#plotting the two years side by side using patchwork
bi_1 + bi_2
```


```{r}
# this is the code needed to call from the census data
racevars <- c(Black = "B02001_003")

# getting the 5-year census data relevant to Suffolk county and the population
# data about black people in this county in 2022

boston_race_22 <- get_acs(
  geography = "cbg",
  variables = racevars,
  state = "MA",
  county = "Suffolk",
  geometry = TRUE,
  summary_var = "B02001_001",
  year = 2022,
)

# plotting the percent of the population that is black in suffolk county in 2022
# in the style of a choropleth map with the station locations layed overtop

boston_race_22 %>%
  mutate(percent = 100 * (estimate / summary_est)) %>%
  ggplot(aes(fill = percent)) +
  facet_wrap(~variable) +
  geom_sf(color = NA) +
   geom_point(
    data = station_populations_16_22,
    aes(x = lon, y = lat, fill = diff_norm_entry),
    color = "red")+
  theme_void() +
  scale_fill_viridis_c() +
  labs(fill = "% of population", subtitle = "2022 census", title = "Red Line station locations")

```


```{r, "MBTA usage"}
# getting the 5-year census data relevant to Suffolk county and if people use
# the light rail and subway to get to work in 2016
boston_transport_16 <- get_acs(
  state = "MA",
  county = "Suffolk",
  geography = "cbg",
  variables = transvars,
  geometry = TRUE,
  summary_var = "B08301_001",
  year = 2016,
)


# getting the 5-year census data relevant to Suffolk county and if people use
# the light rail and subway to get to work in 2022
boston_transport_22 <- get_acs(
  state = "MA",
  county = "Suffolk",
  geography = "cbg",
  variables = transvars,
  geometry = TRUE,
  summary_var = "B08301_001",
  year = 2022,
)


#plotting the percent of population that uses the light rail/ subway to get to work
# on a choropleth map. Also plotting the station locations of the red line on top
# for both 2016 and 2022

bt_1 <- boston_transport_16 %>%
  group_by(GEOID) %>%
  summarise(estimate = sum(estimate), summary_est = mean(summary_est)) %>%
  mutate(percent = 100 * (estimate / summary_est)) %>%
  ggplot(aes(fill = percent)) +
  geom_sf(color = NA) +
  geom_point(
    data = station_populations_16_22,
    aes(x = lon, y = lat, fill = diff_norm_entry),
    color = "red")+
  theme_void() +
  scale_fill_viridis_c(option = "turbo", limits = c(0, 100)) +
  labs(
    title = "Percentage of Population \nthat uses the Lightrail/Subway",
    subtitle = "2016 census"
  ) +
  theme(legend.position = "None")

bt_2 <- boston_transport_22 %>%
  group_by(GEOID) %>%
  summarise(estimate = sum(estimate), summary_est = mean(summary_est)) %>%
  mutate(percent = 100 * (estimate / summary_est)) %>%
  ggplot(aes(fill = percent)) +
  geom_sf(color = NA) +
  geom_point(
    data = station_populations_16_22,
    aes(x = lon, y = lat, fill = diff_norm_entry),
    color = "red")+
  theme_void() +
  scale_fill_viridis_c(option = "turbo", limits = c(0, 100)) +
  labs(fill = "% of population", subtitle = "2022 census")

#plotting the two years side by side using patchwork

bt_1 + bt_2
```



